/*
 * Copyright 2002-2023 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.springframework.beans.factory.aot;

import java.io.InputStream;
import java.io.OutputStream;
import java.lang.reflect.InvocationTargetException;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.time.temporal.ChronoUnit;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.IdentityHashMap;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.function.BiConsumer;
import java.util.function.Supplier;

import javax.lang.model.element.Modifier;

import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;

import org.springframework.aot.generate.GeneratedClass;
import org.springframework.aot.generate.ValueCodeGenerationException;
import org.springframework.aot.generate.ValueCodeGenerator;
import org.springframework.aot.generate.ValueCodeGeneratorDelegates;
import org.springframework.aot.test.generate.TestGenerationContext;
import org.springframework.beans.factory.aot.support.NestableObject;
import org.springframework.beans.factory.aot.support.NestableRecord;
import org.springframework.beans.factory.aot.support.ObjectPair;
import org.springframework.beans.factory.aot.support.ObjectWithMissingConstructor;
import org.springframework.beans.factory.aot.support.ObjectWithMissingSetter;
import org.springframework.beans.factory.aot.support.ObjectWithPrivateConstructor;
import org.springframework.beans.factory.aot.support.ObjectWithPrivateSetter;
import org.springframework.beans.factory.aot.support.ObjectWithRecord;
import org.springframework.beans.factory.aot.support.ProtectedObjectCreator;
import org.springframework.beans.factory.aot.support.RecordPair;
import org.springframework.beans.factory.aot.support.RecordWithObject;
import org.springframework.beans.factory.config.BeanReference;
import org.springframework.beans.factory.config.RuntimeBeanNameReference;
import org.springframework.beans.factory.config.RuntimeBeanReference;
import org.springframework.beans.factory.support.ManagedList;
import org.springframework.beans.factory.support.ManagedMap;
import org.springframework.beans.factory.support.ManagedSet;
import org.springframework.beans.testfixture.beans.factory.aot.DeferredTypeBuilder;
import org.springframework.core.ResolvableType;
import org.springframework.core.test.tools.Compiled;
import org.springframework.core.test.tools.TestCompiler;
import org.springframework.core.testfixture.aot.generate.value.EnumWithClassBody;
import org.springframework.core.testfixture.aot.generate.value.ExampleClass;
import org.springframework.core.testfixture.aot.generate.value.ExampleClass$$GeneratedBy;
import org.springframework.javapoet.CodeBlock;
import org.springframework.javapoet.MethodSpec;
import org.springframework.javapoet.ParameterizedTypeName;
import org.springframework.util.ReflectionUtils;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatCode;

/**
 * Tests for {@link BeanDefinitionPropertyValueCodeGeneratorDelegates}. This
 * also tests that code generated by {@link ValueCodeGeneratorDelegates}
 * compiles.
 *
 * @author Stephane Nicoll
 * @author Phillip Webb
 * @author Sebastien Deleuze
 * @since 6.0
 */
class BeanDefinitionPropertyValueCodeGeneratorDelegatesTests {

	private static ValueCodeGenerator createValueCodeGenerator(GeneratedClass generatedClass) {
		return ValueCodeGenerator.with(BeanDefinitionPropertyValueCodeGeneratorDelegates.INSTANCES)
				.add(ValueCodeGeneratorDelegates.INSTANCES)
				.scoped(generatedClass.getMethods());
	}

	private void compile(Object value, BiConsumer<Object, Compiled> result) {
		TestGenerationContext generationContext = new TestGenerationContext();
		DeferredTypeBuilder typeBuilder = new DeferredTypeBuilder();
		GeneratedClass generatedClass = generationContext.getGeneratedClasses().addForFeature("TestCode", typeBuilder);
		CodeBlock generatedCode = createValueCodeGenerator(generatedClass).generateCode(value);
		typeBuilder.set(type -> {
			type.addModifiers(Modifier.PUBLIC);
			type.addSuperinterface(
					ParameterizedTypeName.get(Supplier.class, Object.class));
			type.addMethod(MethodSpec.methodBuilder("get").addModifiers(Modifier.PUBLIC)
					.returns(Object.class).addStatement("return $L", generatedCode).build());
		});
		generationContext.writeGeneratedContent();
		TestCompiler.forSystem().with(generationContext).compile(compiled ->
				result.accept(compiled.getInstance(Supplier.class).get(), compiled));
	}

	@Nested
	class NullTests {

		@Test
		void generateWhenNull() {
			compile(null, (instance, compiled) -> assertThat(instance).isNull());
		}

	}

	@Nested
	class PrimitiveTests {

		@Test
		void generateWhenBoolean() {
			compile(true, (instance, compiled) ->
					assertThat(instance).isEqualTo(Boolean.TRUE));
		}

		@Test
		void generateWhenByte() {
			compile((byte) 2, (instance, compiled) ->
					assertThat(instance).isEqualTo((byte) 2));
		}

		@Test
		void generateWhenShort() {
			compile((short) 3, (instance, compiled) ->
					assertThat(instance).isEqualTo((short) 3));
		}

		@Test
		void generateWhenInt() {
			compile(4, (instance, compiled) ->
					assertThat(instance).isEqualTo(4));
		}

		@Test
		void generateWhenLong() {
			compile(5L, (instance, compiled) ->
					assertThat(instance).isEqualTo(5L));
		}

		@Test
		void generateWhenFloat() {
			compile(0.1F, (instance, compiled) ->
					assertThat(instance).isEqualTo(0.1F));
		}

		@Test
		void generateWhenDouble() {
			compile(0.2, (instance, compiled) ->
					assertThat(instance).isEqualTo(0.2));
		}

		@Test
		void generateWhenChar() {
			compile('a', (instance, compiled) ->
					assertThat(instance).isEqualTo('a'));
		}

		@Test
		void generateWhenSimpleEscapedCharReturnsEscaped() {
			testEscaped('\b');
			testEscaped('\t');
			testEscaped('\n');
			testEscaped('\f');
			testEscaped('\r');
			testEscaped('\"');
			testEscaped('\'');
			testEscaped('\\');
		}

		@Test
		void generatedWhenUnicodeEscapedCharReturnsEscaped() {
			testEscaped('\u007f');
		}

		private void testEscaped(char value) {
			compile(value, (instance, compiled) ->
					assertThat(instance).isEqualTo(value));
		}

	}

	@Nested
	class StringTests {

		@Test
		void generateWhenString() {
			compile("test\n", (instance, compiled) ->
					assertThat(instance).isEqualTo("test\n"));
		}

	}

	@Nested
	class CharsetTests {

		@Test
		void generateWhenCharset() {
			compile(StandardCharsets.UTF_8, (instance, compiled) ->
					assertThat(instance).isEqualTo(Charset.forName("UTF-8")));
		}

	}

	@Nested
	class EnumTests {

		@Test
		void generateWhenEnum() {
			compile(ChronoUnit.DAYS, (instance, compiled) ->
					assertThat(instance).isEqualTo(ChronoUnit.DAYS));
		}

		@Test
		void generateWhenEnumWithClassBody() {
			compile(EnumWithClassBody.TWO, (instance, compiled) ->
					assertThat(instance).isEqualTo(EnumWithClassBody.TWO));
		}

	}

	@Nested
	class ClassTests {

		@Test
		void generateWhenClass() {
			compile(InputStream.class, (instance, compiled) -> assertThat(instance)
					.isEqualTo(InputStream.class));
		}

		@Test
		void generateWhenCglibClass() {
			compile(ExampleClass$$GeneratedBy.class, (instance,
					compiled) -> assertThat(instance).isEqualTo(ExampleClass.class));
		}

	}

	@Nested
	class ResolvableTypeTests {

		@Test
		void generateWhenSimpleResolvableType() {
			ResolvableType resolvableType = ResolvableType.forClass(String.class);
			compile(resolvableType, (instance, compiled) -> assertThat(instance)
					.isEqualTo(resolvableType));
		}

		@Test
		void generateWhenNoneResolvableType() {
			ResolvableType resolvableType = ResolvableType.NONE;
			compile(resolvableType, (instance, compiled) ->
					assertThat(instance).isEqualTo(resolvableType));
		}

		@Test
		void generateWhenGenericResolvableType() {
			ResolvableType resolvableType = ResolvableType
					.forClassWithGenerics(List.class, String.class);
			compile(resolvableType, (instance, compiled) ->
					assertThat(instance).isEqualTo(resolvableType));
		}

		@Test
		void generateWhenNestedGenericResolvableType() {
			ResolvableType stringList = ResolvableType.forClassWithGenerics(List.class,
					String.class);
			ResolvableType resolvableType = ResolvableType.forClassWithGenerics(Map.class,
					ResolvableType.forClass(Integer.class), stringList);
			compile(resolvableType, (instance, compiled) -> assertThat(instance)
					.isEqualTo(resolvableType));
		}

	}

	@Nested
	class ArrayTests {

		@Test
		void generateWhenPrimitiveArray() {
			byte[] bytes = { 0, 1, 2 };
			compile(bytes, (instance, compiler) ->
					assertThat(instance).isEqualTo(bytes));
		}

		@Test
		void generateWhenWrapperArray() {
			Byte[] bytes = { 0, 1, 2 };
			compile(bytes, (instance, compiler) ->
					assertThat(instance).isEqualTo(bytes));
		}

		@Test
		void generateWhenClassArray() {
			Class<?>[] classes = new Class<?>[] { InputStream.class, OutputStream.class };
			compile(classes, (instance, compiler) ->
					assertThat(instance).isEqualTo(classes));
		}

		@Test
		void noGenerateWhenSelfReference() {
			Object[] items = new Object[1];
			items[0] = items;
			ValueCodeGenerator valueCodeGenerator = ValueCodeGenerator.withDefaults();
			assertThatCode(() -> valueCodeGenerator.generateCode(items))
					.isInstanceOf(ValueCodeGenerationException.class);
		}

	}

	@Nested
	class ManagedListTests {

		@Test
		void generateWhenStringManagedList() {
			ManagedList<String> list = new ManagedList<>();
			list.add("a");
			list.add("b");
			list.add("c");
			compile(list, (instance, compiler) -> assertThat(instance).isEqualTo(list)
					.isInstanceOf(ManagedList.class));
		}

		@Test
		void generateWhenEmptyManagedList() {
			ManagedList<String> list = new ManagedList<>();
			compile(list, (instance, compiler) -> assertThat(instance).isEqualTo(list)
					.isInstanceOf(ManagedList.class));
		}

		@Test
		void noGenerateWhenSelfReference() {
			ManagedList<Object> list = new ManagedList<>();
			list.add(list);
			ValueCodeGenerator valueCodeGenerator = ValueCodeGenerator.withDefaults();
			assertThatCode(() -> valueCodeGenerator.generateCode(list))
					.isInstanceOf(ValueCodeGenerationException.class);
		}

	}

	@Nested
	class ManagedSetTests {

		@Test
		void generateWhenStringManagedSet() {
			ManagedSet<String> set = new ManagedSet<>();
			set.add("a");
			set.add("b");
			set.add("c");
			compile(set, (instance, compiler) -> assertThat(instance).isEqualTo(set)
					.isInstanceOf(ManagedSet.class));
		}

		@Test
		void generateWhenEmptyManagedSet() {
			ManagedSet<String> set = new ManagedSet<>();
			compile(set, (instance, compiler) -> assertThat(instance).isEqualTo(set)
					.isInstanceOf(ManagedSet.class));
		}
	}

	@Nested
	class ManagedMapTests {

		@Test
		void generateWhenManagedMap() {
			ManagedMap<String, String> map = new ManagedMap<>();
			map.put("k1", "v1");
			map.put("k2", "v2");
			compile(map, (instance, compiler) -> assertThat(instance).isEqualTo(map)
					.isInstanceOf(ManagedMap.class));
		}

		@Test
		void generateWhenEmptyManagedMap() {
			ManagedMap<String, String> map = new ManagedMap<>();
			compile(map, (instance, compiler) -> assertThat(instance).isEqualTo(map)
					.isInstanceOf(ManagedMap.class));
		}
	}

	@Nested
	class ListTests {

		@Test
		void generateWhenStringList() {
			List<String> list = List.of("a", "b", "c");
			compile(list, (instance, compiler) -> assertThat(instance).isEqualTo(list)
					.isNotInstanceOf(ManagedList.class));
		}

		@Test
		void generateWhenEmptyList() {
			List<String> list = List.of();
			compile(list, (instance, compiler) -> assertThat(instance).isEqualTo(list));
		}

		@Test
		void noGenerateWhenSelfReference() {
			List<Object> list = new ArrayList<>();
			list.add(list);
			ValueCodeGenerator valueCodeGenerator = ValueCodeGenerator.withDefaults();
			assertThatCode(() -> valueCodeGenerator.generateCode(list))
					.isInstanceOf(ValueCodeGenerationException.class);
		}

	}

	@Nested
	class SetTests {

		@Test
		void generateWhenStringSet() {
			Set<String> set = Set.of("a", "b", "c");
			compile(set, (instance, compiler) -> assertThat(instance).isEqualTo(set)
					.isNotInstanceOf(ManagedSet.class));
		}

		@Test
		void generateWhenEmptySet() {
			Set<String> set = Set.of();
			compile(set, (instance, compiler) -> assertThat(instance).isEqualTo(set));
		}

		@Test
		void generateWhenLinkedHashSet() {
			Set<String> set = new LinkedHashSet<>(List.of("a", "b", "c"));
			compile(set, (instance, compiler) ->
					assertThat(instance).isEqualTo(set).isInstanceOf(LinkedHashSet.class));
		}

		@Test
		void generateWhenSetOfClass() {
			Set<Class<?>> set = Set.of(String.class, Integer.class, Long.class);
			compile(set, (instance, compiler) -> assertThat(instance).isEqualTo(set));
		}
	}

	@Nested
	class MapTests {

		@Test
		void generateWhenSmallMap() {
			Map<String, String> map = Map.of("k1", "v1", "k2", "v2");
			compile(map, (instance, compiler) ->
					assertThat(instance).isEqualTo(map));
		}

		@Test
		void generateWhenMapWithOverTenElements() {
			Map<String, String> map = new HashMap<>();
			for (int i = 1; i <= 11; i++) {
				map.put("k" + i, "v" + i);
			}
			compile(map, (instance, compiler) -> assertThat(instance).isEqualTo(map));
		}

		@Test
		void generateWhenLinkedHashMap() {
			Map<String, String> map = new LinkedHashMap<>();
			map.put("a", "A");
			map.put("b", "B");
			map.put("c", "C");
			compile(map, (instance, compiler) -> {
				assertThat(instance).isEqualTo(map).isInstanceOf(LinkedHashMap.class);
				assertThat(compiler.getSourceFile()).contains("getMap()");
			});
		}

		@Test
		void noGenerateWhenSelfReference() {
			Map<Object, Object> map = new IdentityHashMap<>();
			map.put(map, map);
			ValueCodeGenerator valueCodeGenerator = ValueCodeGenerator.withDefaults();
			assertThatCode(() -> valueCodeGenerator.generateCode(map))
					.isInstanceOf(ValueCodeGenerationException.class);
		}

	}

	@Nested
	class RecordTests {
		@Test
		void generatedPublicRecord() {
			NestableRecord record = new NestableRecord(0, "record", null);
			compile(record, (instance, compiler) -> {
				NestableRecord actual = (NestableRecord) instance;
				assertThat(actual).isEqualTo(record);
			});
		}

		@Test
		void generatedNestedPublicRecord() {
			NestableRecord record = new NestableRecord(0, "parent", new NestableRecord(1, "child", null));
			compile(record, (instance, compiler) -> {
				NestableRecord actual = (NestableRecord) instance;
				assertThat(actual).isEqualTo(record);
			});
		}

		@Test
		void generatedNestedWithObjects() {
			RecordWithObject record = new RecordWithObject(0, new ObjectWithRecord(1, new RecordWithObject(2, new ObjectWithRecord(3, null))));
			compile(record, (instance, compiler) -> {
				RecordWithObject actual = (RecordWithObject) instance;
				assertThat(actual).isEqualTo(record);
			});
		}

		@Test
		void generatedGenericRecord() {
			RecordPair<String, Integer> pair = new RecordPair<>("Left", 1);
			compile(pair, (instance, compiler) -> {
				RecordPair<?, ?> actual = (RecordPair<?, ?>) instance;
				assertThat(actual).isEqualTo(pair);
			});
		}

		@Test
		void notGeneratedCyclicRecord() {
			ValueCodeGenerator valueCodeGenerator = ValueCodeGenerator.withDefaults();
			ObjectWithRecord cycleEnd = new ObjectWithRecord(1);
			RecordWithObject cycleStart = new RecordWithObject(0, cycleEnd);
			cycleEnd.setNested(cycleStart);
			assertThatCode(() -> valueCodeGenerator.generateCode(cycleStart))
					.isInstanceOf(ValueCodeGenerationException.class);
		}

		@Test
		void notGeneratedProtectedRecord() {
			ValueCodeGenerator valueCodeGenerator = ValueCodeGenerator.withDefaults();
			assertThatCode(() -> valueCodeGenerator.generateCode(ProtectedObjectCreator.getProtectedRecord()))
					.isInstanceOf(ValueCodeGenerationException.class);
		}

		public record InaccessibleRecord() {}

		@Test
		void notGeneratedPublicRecordInProtectedClass() {
			ValueCodeGenerator valueCodeGenerator = ValueCodeGenerator.withDefaults();
			assertThatCode(() -> valueCodeGenerator.generateCode(new InaccessibleRecord()))
					.isInstanceOf(ValueCodeGenerationException.class);
		}
	}

	@Nested
	class ObjectTests {
		@Test
		void generatedPublicObject() {
			NestableObject object = new NestableObject();
			object.name = "Object";
			object.setId(1);
			object.setNested(null);
			compile(object, (instance, compiler) -> {
				NestableObject actual = (NestableObject) instance;
				assertThat(actual).isEqualTo(object);
			});
		}

		@Test
		void generatedNestedPublicObject() {
			NestableObject parent = new NestableObject();
			parent.name = "Parent";
			parent.setId(1);
			NestableObject child = new NestableObject();
			child.name = "Child";
			child.setId(2);
			child.setNested(null);
			parent.setNested(child);
			compile(parent, (instance, compiler) -> {
				NestableObject actual = (NestableObject) instance;
				assertThat(actual).isEqualTo(parent);
			});
		}

		@Test
		void generatedGeneric() {
			ObjectPair<String, Integer> pair = new ObjectPair<>("Test", 1);
			compile(pair, (instance, compiler) -> {
				ObjectPair<?, ?> actual = (ObjectPair<?, ?>) instance;
				assertThat(actual).isEqualTo(pair);
			});
		}

		@Test
		void generatedPairOfObjects() {
			ObjectPair<ObjectPair<String, Integer>, ObjectPair<Integer, String>> pair =
					new ObjectPair<>(new ObjectPair<>("Left", 0),
							new ObjectPair<>(1, "Right"));
			compile(pair, (instance, compiler) -> {
				ObjectPair<?, ?> actual = (ObjectPair<?, ?>) instance;
				assertThat(actual).isEqualTo(pair);
			});
		}

		@Test
		void generatedNestedWithRecords() {
			ObjectWithRecord object = new ObjectWithRecord(0, new RecordWithObject(1, new ObjectWithRecord(2, new RecordWithObject(3, null))));
			compile(object, (instance, compiler) -> {
				ObjectWithRecord actual = (ObjectWithRecord) instance;
				assertThat(actual).isEqualTo(object);
			});
		}

		@Test
		void generatedPairOfObjectsWithinList() {
			var pair = new ObjectPair<>(List.of(new ObjectPair<>("Left", 0)),
							List.of(new ObjectPair<>(1, "Right")));
			compile(pair, (instance, compiler) -> {
				ObjectPair<?, ?> actual = (ObjectPair<?, ?>) instance;
				assertThat(actual).isEqualTo(pair);
			});
		}

		@Test
		void generatedPairOfObjectsWithinSet() {
			var pair = new ObjectPair<>(Set.of(new ObjectPair<>("Left", 0)),
					Set.of(new ObjectPair<>(1, "Right")));
			compile(pair, (instance, compiler) -> {
				ObjectPair<?, ?> actual = (ObjectPair<?, ?>) instance;
				assertThat(actual).isEqualTo(pair);
			});
		}

		@Test
		void generatedPairOfObjectsWithinMap() {
			var pair = new ObjectPair<>(Map.of("a", new ObjectPair<>("Left", 0)),
					Map.of("b", new ObjectPair<>(1, "Right")));
			compile(pair, (instance, compiler) -> {
				ObjectPair<?, ?> actual = (ObjectPair<?, ?>) instance;
				assertThat(actual).isEqualTo(pair);
			});
		}

		@Test
		void notGeneratedProtectedClass() {
			ValueCodeGenerator valueCodeGenerator = ValueCodeGenerator.withDefaults();
			assertThatCode(() -> valueCodeGenerator.generateCode(ProtectedObjectCreator.getProtectedObject()))
					.isInstanceOf(ValueCodeGenerationException.class);
		}

		public static class InaccessibleObject {}

		@Test
		void notGeneratedInaccessibleClass() {
			ValueCodeGenerator valueCodeGenerator = ValueCodeGenerator.withDefaults();
			assertThatCode(() -> valueCodeGenerator.generateCode(new InaccessibleObject()))
					.isInstanceOf(ValueCodeGenerationException.class);
		}

		@Test
		void notGeneratedMissingConstructor() {
			ValueCodeGenerator valueCodeGenerator = ValueCodeGenerator.withDefaults();
			assertThatCode(() -> valueCodeGenerator.generateCode(new ObjectWithMissingConstructor("value")))
					.isInstanceOf(ValueCodeGenerationException.class);
		}

		@Test
		void notGeneratedPrivateConstructor()
				throws NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException {
			ValueCodeGenerator valueCodeGenerator = ValueCodeGenerator.withDefaults();
			ObjectWithPrivateConstructor instance = ReflectionUtils.accessibleConstructor(ObjectWithPrivateConstructor.class).newInstance();
			assertThatCode(() -> valueCodeGenerator.generateCode(instance))
					.isInstanceOf(ValueCodeGenerationException.class);
		}

		@Test
		void notGeneratedMissingSetter() {
			ValueCodeGenerator valueCodeGenerator = ValueCodeGenerator.withDefaults();
			assertThatCode(() -> valueCodeGenerator.generateCode(new ObjectWithMissingSetter()))
					.isInstanceOf(ValueCodeGenerationException.class);
		}

		@Test
		void notGeneratedPrivateSetter() {
			ValueCodeGenerator valueCodeGenerator = ValueCodeGenerator.withDefaults();
			assertThatCode(() -> valueCodeGenerator.generateCode(new ObjectWithPrivateSetter()))
					.isInstanceOf(ValueCodeGenerationException.class);
		}

		@Test
		void notGeneratedCyclicPublicObject() {
			NestableObject cyclicObject = new NestableObject();
			cyclicObject.name = "Cyclic";
			cyclicObject.setId(0);
			cyclicObject.setNested(cyclicObject);
			ValueCodeGenerator valueCodeGenerator = ValueCodeGenerator.withDefaults();
			assertThatCode(() -> valueCodeGenerator.generateCode(cyclicObject))
					.isInstanceOf(ValueCodeGenerationException.class);
		}

		@Test
		void notGeneratedCyclicObjectFromRecord() {
			ValueCodeGenerator valueCodeGenerator = ValueCodeGenerator.withDefaults();
			ObjectWithRecord cycleEnd = new ObjectWithRecord(1);
			RecordWithObject cycleStart = new RecordWithObject(0, cycleEnd);
			cycleEnd.setNested(cycleStart);
			assertThatCode(() -> valueCodeGenerator.generateCode(cycleEnd))
					.isInstanceOf(ValueCodeGenerationException.class);
		}
	}

	@Nested
	class BeanReferenceTests {

		@Test
		void generatedWhenBeanNameReference() {
			RuntimeBeanNameReference beanReference = new RuntimeBeanNameReference("test");
			compile(beanReference, (instance, compiler) -> {
				RuntimeBeanReference actual = (RuntimeBeanReference) instance;
				assertThat(actual.getBeanName()).isEqualTo(beanReference.getBeanName());
			});
		}

		@Test
		void generatedWhenBeanReferenceByName() {
			RuntimeBeanReference beanReference = new RuntimeBeanReference("test");
			compile(beanReference, (instance, compiler) -> {
				RuntimeBeanReference actual = (RuntimeBeanReference) instance;
				assertThat(actual.getBeanName()).isEqualTo(beanReference.getBeanName());
				assertThat(actual.getBeanType()).isEqualTo(beanReference.getBeanType());
			});
		}

		@Test
		void generatedWhenBeanReferenceByType() {
			BeanReference beanReference = new RuntimeBeanReference(String.class);
			compile(beanReference, (instance, compiler) -> {
				RuntimeBeanReference actual = (RuntimeBeanReference) instance;
				assertThat(actual.getBeanType()).isEqualTo(String.class);
			});
		}
	}
}

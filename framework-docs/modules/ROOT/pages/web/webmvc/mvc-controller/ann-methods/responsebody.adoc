[[mvc-ann-responsebody]]
= `@ResponseBody`

[.small]#<<web-reactive.adoc#webflux-ann-responsebody, See equivalent in the Reactive stack>>#

You can use the `@ResponseBody` annotation on a method to have the return serialized
to the response body through an
<<integration.adoc#rest-message-conversion, HttpMessageConverter>>.
The following listing shows an example:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@GetMapping("/accounts/{id}")
	@ResponseBody
	public Account handle() {
		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@GetMapping("/accounts/{id}")
	@ResponseBody
	fun handle(): Account {
		// ...
	}
----

`@ResponseBody` is also supported at the class level, in which case it is inherited by
all controller methods. This is the effect of `@RestController`, which is nothing more
than a meta-annotation marked with `@Controller` and `@ResponseBody`.

You can use `@ResponseBody` with reactive types.
See <<mvc-ann-async>> and <<mvc-ann-async-reactive-types>> for more details.

You can use the <<mvc-config-message-converters>> option of the <<mvc-config>> to
configure or customize message conversion.

You can combine `@ResponseBody` methods with JSON serialization views.
See <<mvc-ann-jackson>> for details.



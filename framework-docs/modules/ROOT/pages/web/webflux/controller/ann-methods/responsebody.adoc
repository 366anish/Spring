[[webflux-ann-responsebody]]
= `@ResponseBody`

[.small]#<<web.adoc#mvc-ann-responsebody, See equivalent in the Servlet stack>>#

You can use the `@ResponseBody` annotation on a method to have the return serialized
to the response body through an <<webflux-codecs, HttpMessageWriter>>. The following
example shows how to do so:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@GetMapping("/accounts/{id}")
	@ResponseBody
	public Account handle() {
		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@GetMapping("/accounts/{id}")
	@ResponseBody
	fun handle(): Account {
		// ...
	}
----

`@ResponseBody` is also supported at the class level, in which case it is inherited by
all controller methods. This is the effect of `@RestController`, which is nothing more
than a meta-annotation marked with `@Controller` and `@ResponseBody`.

`@ResponseBody` supports reactive types, which means you can return Reactor or RxJava
types and have the asynchronous values they produce rendered to the response.
For additional details, see <<webflux-codecs-streaming>> and
<<webflux-codecs-jackson,JSON rendering>>.

You can combine `@ResponseBody` methods with JSON serialization views.
See <<webflux-ann-jackson>> for details.

You can use the <<webflux-config-message-codecs>> option of the <<webflux-config>> to
configure or customize message writing.



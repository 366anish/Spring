spring ioc 的本质就是：
1.先是对资源进行定位，明确资源的位置，不管是什么类型的资源（比如网络资源，文件资源，二进制字节流等等），不管是一个资源还是多个资源，以及带通配符的资源路径进行匹配。
2.确定了资源，BeanDefinitionReader就要对资源进行解析，解析出bean的元数据信息赋值到BeanDefinition上，内部对BeanDefinition使用单例池进行缓存，本质是一个map<id，BeanDefinition>。
3.
---------------------------------------------------------------------------------------------------
一.IoC 之 Spring 统一资源加载策略
总结：spring提供了Resource接口和ResourceLoader接口来抽象资源和资源的加载。默认的实现分别是AbstractResource和DefaultResourceLoader。
这样做的好处是让资源和资源的加载又一个清晰的界线。
AbstractResource有几个实现分别是：
    FileSystemResource ：对 java.io.File 类型资源的封装，只要是跟 File 打交道的，基本上与 FileSystemResource 也可以打交道。支持文件和 URL 的形式，实现 WritableResource 接口，
    且从 Spring Framework 5.0 开始，FileSystemResource 使用 NIO2 API进行读/写交互。
    ByteArrayResource ：对字节数组提供的数据的封装。如果通过 InputStream 形式访问该类型的资源，该实现会根据字节数组的数据构造一个相应的 ByteArrayInputStream。
    UrlResource ：对 java.net.URL类型资源的封装。内部委派 URL 进行具体的资源操作。
    ClassPathResource ：class path 类型资源的实现。使用给定的 ClassLoader 或者给定的 Class 来加载资源。
    InputStreamResource ：将给定的 InputStream 作为一种资源的 Resource 的实现类。
DefaultResourceLoader(每次只能加载单一的文件):
    我们除了可以继承该类外还可以实现 ProtocolResolver 接口来实现自定资源加载协议。
ResourcePatternResolver（可以加载多个文件，使用通配符匹配）:
    PathMatchingResourcePatternResolver功能很强大，实现了上面两个方法的总和。
以上就是spring资源定位的过程。
---------------------------------------------------------------------------------------------------
二、IoC 之开启 Bean 的加载

1.容器初始化阶段：
  ---> 通过某种方式加载 Configuration Metadata (主要是依据 Resource、ResourceLoader 两个体系) 。
  ---> 然后，容器会对加载的 Configuration MetaData 进行解析和分析，并将分析的信息组装成 BeanDefinition 。
  ---> 最后，将 BeanDefinition 保存注册到相应的 BeanDefinitionRegistry 中。
  ---> 至此，Spring IoC 的初始化工作完成。
2.加载 Bean 阶段：
  ---> 经过容器初始化阶段后，应用程序中定义的 bean 信息已经全部加载到系统中了，当我们显示或者隐式地调用 BeanFactory#getBean(...) 方法时，则会触发加载 Bean 阶段。
  ---> 在这阶段，容器会首先检查所请求的对象是否已经初始化完成了，如果没有，则会根据注册的 Bean 信息实例化请求的对象，并为其注册依赖，然后将其返回给请求方。

总结：
    1.分析从缓存中获取单例 Bean ，以及对 Bean 的实例中获取对象。
    2.如果从单例缓存中获取 Bean ，Spring 是怎么加载的呢？所以第二部分是分析 Bean 加载，以及 Bean 的依赖处理。
    3.Bean 已经加载了，依赖也处理完毕了，第三部分则分析各个作用域的 Bean 初始化过程。
---------------------------------------------------------------------------------------------------
spring ioc之Aware接口：
Bean实例化会执行Aware接口依次为：
            调用了 BeanNameAware 的 setBeanName 方法
            调用了 BeanClassLoaderAware 的 setBeanClassLoader 方法
            调用了 BeanFactoryAware 的 setBeanFactory 方法
            调用了 ApplicationContextAware 的 setApplicationContext 方法

便于查询----->
            LoadTimeWeaverAware：加载Spring Bean时织入第三方模块，如AspectJ
            BeanClassLoaderAware：加载Spring Bean的类加载器
            BootstrapContextAware：资源适配器BootstrapContext，如JCA,CCI
            ResourceLoaderAware：底层访问资源的加载器
            BeanFactoryAware：声明BeanFactory
            PortletConfigAware：PortletConfig
            PortletContextAware：PortletContext
            ServletConfigAware：ServletConfig
            ServletContextAware：ServletContext
            MessageSourceAware：国际化
            ApplicationEventPublisherAware：应用事件
            NotificationPublisherAware：JMX通知
            BeanNameAware：声明Spring Bean的名字
---------------------------------------------------------------------------------------------------
IoC 之加载 Bean：从单例缓存中获取单例 Bean
DefaultSingletonBeanRegistry.getSingleton(java.lang.String)







